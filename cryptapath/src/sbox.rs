//! A S-Box in a cryptosystem. 
//! The purpose of the S-Box is double: 
//! - when a S-Box is applied to a Vec<Bit> containing only constant bit
//! (ie bits which don't contain variables) it should produce a Vec<Bit>
//! of constant bits matching its lookup table. This is useful to validate
//! the implementation of a cryptosystem by checking test vectors.
//! 
//! - when a S-Box is applied to a Vec<Bit> with bits whose value is unknown
//! (ie at least one of the bit contains variables) the S-Box should output
//! fresh Bit containing new variables and generate a BDD that will be use later
//! when trying to solve the system of BDD obtain by running the cryptosystem

use crate::bit::Bit;
use crate::crush::soc::{
    utils::{BddSpec, LevelSpec, NodeSpec},
    Id,
};
use std::cell::{Cell, RefCell};

/// A S-Box, with in_size the number of bit to enter the S-Box, out_size the
/// number of bit to be outputted by an application of the S-Box and table
/// its lookup table.
/// next_var_id is used when new bits need to be outputted to produce the variables
/// and bdds hold all the BDD generated by the S-Box.
#[derive(Clone)]
pub struct Sbox {
    in_size: usize,
    out_size: usize,
    table: Vec<u8>,
    next_var_id: Cell<usize>,
    bdds: RefCell<Vec<BddSpec>>,
}
impl Sbox {

    /// A constructor for an SBox
    pub fn new(in_size: usize, out_size: usize, table: Vec<u8>, next_var_id: usize) -> Self {
        assert_eq!(1 << in_size, table.len());

        Sbox {
            in_size,
            out_size,
            table,
            next_var_id: Cell::new(next_var_id),
            bdds: RefCell::new(Vec::new()),
        }
    }

    /// Return a new SBox with specified parameters that keeps the next_var_id
    /// and the BDDs of a previous SBox, useful for ciphers that use several SBoxes
    pub fn replace_existing_sbox(
        in_size: usize,
        out_size: usize,
        table: Vec<u8>,
        mut old_sbox:Sbox,
    ) -> Self {
        assert_eq!(1 << in_size, table.len());
        Sbox {
            in_size,
            out_size,
            table,
            next_var_id: Cell::new(old_sbox.next_var_id()),
            bdds: RefCell::new(old_sbox.bdds()),
        }
    }

    /// Produce a deterministic output of constant bits by using the
    /// lookup table.
    fn sbox_fixed_output(&self, in_bits: Vec<Bit>) -> Vec<Bit> {
        let in_value = usize::from_str_radix(
            in_bits
                .iter()
                .map(|bit| if bit.constant() { "1" } else { "0" })
                .collect::<String>()
                .as_str(),
            2,
        )
        .unwrap();
        assert!(in_value < (1 << self.in_size));
        let out_value = self.table[in_value];
        let mut out_bits = Vec::with_capacity(self.out_size);
        for i in 0..self.out_size {
            match out_value >> (self.out_size - i - 1) & 0x01 {
                0 => out_bits.push(bit!(false)),
                1 => out_bits.push(bit!(true)),
                _ => panic!("will not happen"),
            }
        }
        out_bits
    }

    /// Return either a Vec of constant bits if all bits are constant
    /// or new set of Bit containing new Variable if at least one of them
    /// is not constant. In that case also produce and store a BDD.
    pub fn apply(&self, in_bits: Vec<Bit>) -> Vec<Bit> {
        if in_bits.iter().find(|bit| bit.vars().next().is_some()).is_none() {
            self.sbox_fixed_output(in_bits)
        } else {
            let mut out_bits = Vec::with_capacity(self.out_size);
            for i in self.next_var_id.get()..self.next_var_id.get() + self.out_size {
                out_bits.push(Bit::from_variable_id(i))
            }
            self.next_var_id.set(self.next_var_id.get() + self.out_size);
            self.bdds
                .borrow_mut()
                .push(buid_bdd_spec(in_bits, out_bits.clone(), &self.table));
            out_bits
        }
    }
    
    /// Returns the BDDs built by the S-Box (remove them from the S-Box).
    pub fn bdds(&mut self) -> Vec<BddSpec> {
        self.bdds.replace(Vec::new())
    }

    /// Return the next_var_id of the S-Box (ie the last variable made
    /// by the S-Box + 1 ).
    #[inline]
    pub fn next_var_id(&self) -> usize {
        self.next_var_id.get()
    }
}

/// Make a BDDSpec out of the entry bits and the out bits of the SBox by using the 
/// lookup table to build the graph.
/// First the top part of the BDD is made by making the top layers of the BDD (from the top_layers).
/// The nodes from the last level of the top layers are connected to the corresponding node from
/// the bottom layers. To find which node should be connected to which we use the lookup table
/// (provided by the parameter mapping). The bottom layers are constructed like the top layers
/// but starting from the sink, in reverse order. So, using the mapping the node corresponding
/// to the entry path n as to be connected to mapping[n] with its bit reversed.
/// The lhs of each top level comes from the variables of the entry bits (with -1 if the constant
/// is true). The lhs of each bottom level comes from the variables of the out bits.
/// Finally we make the last level with an empty lhs and a single node.
/// 
/// The Id of the BDDSpec is always set to 0 (the function building BDD from BDDspec will manage).
fn buid_bdd_spec(top_layers: Vec<Bit>, lower_layers: Vec<Bit>, mapping: &[u8]) -> BddSpec {
    let mut levels = Vec::with_capacity(top_layers.len() + lower_layers.len() + 1);
    let mut next_node_id = 1;
    for (level_index, bit) in top_layers.iter().enumerate() {
        let nb_nodes = 2usize.pow(level_index as u32);
        let mut nodes = Vec::with_capacity(nb_nodes);
        for i in 0..nb_nodes {
            let id = next_node_id + i;
            let (e0, e1);
            if level_index != top_layers.len() - 1 {
                e0 = next_node_id + nb_nodes + 2 * i;
                e1 = next_node_id + nb_nodes + 1 + 2 * i;
            } else {
                let e0_destination = reverse_bits(mapping[i * 2], lower_layers.len());
                e0 = next_node_id + nb_nodes + e0_destination as usize;
                let e1_destination = reverse_bits(mapping[i * 2 + 1], lower_layers.len());
                e1 = next_node_id + nb_nodes + e1_destination as usize;
            }
            nodes.push(NodeSpec::new(Id::new(id), Id::new(e0), Id::new(e1)));
        }
        let mut lhs: Vec<i64> = bit.vars().map(|var| var.id() as i64).collect();
        if bit.constant() {
            lhs.push(-1i64)
        }
        next_node_id += nb_nodes;
        let level = LevelSpec::new(lhs, nodes);
        levels.push(level);
    }
    for (level_index, bit) in lower_layers.iter().enumerate() {
        let nb_nodes = 2usize.pow((lower_layers.len() - level_index) as u32);
        let mut nodes = Vec::with_capacity(nb_nodes);
        for i in 0..nb_nodes {
            let id = next_node_id + i;
            let (mut e0, mut e1) = (0, 0);
            if i % 2 == 0 {
                e0 = next_node_id + nb_nodes + i / 2;
            } else {
                e1 = next_node_id + nb_nodes + i / 2;
            }
            nodes.push(NodeSpec::new(Id::new(id), Id::new(e0), Id::new(e1)));
        }
        next_node_id += nb_nodes;
        let mut lhs: Vec<i64> = bit.vars().map(|var| var.id() as i64).collect();
        if bit.constant() {
            lhs.push(-1i64)
        }
        let level = LevelSpec::new(lhs, nodes);
        levels.push(level);
    }
    // adding the last level with empty left hand side and no edges
    levels.push(LevelSpec::new(
        vec![],
        vec![NodeSpec::new(Id::new(next_node_id), Id::new(0), Id::new(0))],
    ));
    BddSpec::new(Id::new(0), levels)
}

/// Reverse the order of the last n_bit bits: 
/// 0000_1001 with a 5 n_bit value will return 0001_0010
fn reverse_bits(bits: u8, n_bit: usize) -> u8 {
    let mut tmp = bits;
    tmp = (tmp & 0b1111_0000) >> 4 | (tmp & 0b0000_1111) << 4;
    tmp = (tmp & 0b1100_1100) >> 2 | (tmp & 0b0011_0011) << 2;
    tmp = (tmp & 0b1010_1010) >> 1 | (tmp & 0b0101_0101) << 1;
    tmp.wrapping_shr(8 - n_bit as u32)
}

#[test]
fn test_apply_fixed_output_sbox_keccak() {
    //Keccak expended chi Sbox
    let sbox = Sbox::new(
        5,
        5,
        vec![
            0x00, 0x05, 0x0a, 0x0b, 0x14, 0x11, 0x16, 0x17, 0x09, 0x0c, 0x03, 0x02, 0x0d, 0x08,
            0x0f, 0x0e, 0x12, 0x15, 0x18, 0x1b, 0x06, 0x01, 0x04, 0x07, 0x1a, 0x1d, 0x10, 0x13,
            0x1e, 0x19, 0x1c, 0x1f,
        ],
        0,
    );
    let bits = vec![
        bit!(false),
        bit!(false),
        bit!(false),
        bit!(false),
        bit!(false),
    ];
    let expected = vec![
        bit!(false),
        bit!(false),
        bit!(false),
        bit!(false),
        bit!(false),
    ];
    assert_eq!(expected, sbox.apply(bits));
    let bits = vec![
        bit!(true),
        bit!(false),
        bit!(false),
        bit!(false),
        bit!(false),
    ];
    let expected = vec![
        bit!(true),
        bit!(false),
        bit!(false),
        bit!(true),
        bit!(false),
    ];
    assert_eq!(expected, sbox.apply(bits));
}
